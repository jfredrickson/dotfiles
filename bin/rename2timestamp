#!/bin/bash

set -o nounset
set -o errexit
set -o pipefail

function rename() {
	local action=${1:-0}
	local file=${2:-}
	if [ -z "${file}" ]
	then
		cat >&2 <<- EOF
			No file argument given
			EOF
		return 1
	fi
	if [ ! -r "${file}" ]
	then
		echo "Cannot read $file" >&2
		return 1
	fi

	filepathname=$(realpath --no-symlinks "${file}")
	filename=$(basename "${filepathname}")
	filepath=$(dirname "${filepathname}")
	filenamebase=${filename%.*}
	filenamext=${filename##*.}
	filepoch=$(stat -c %Y "${filepathname}")
	filets=$(date -d @${filepoch} +%Y%m%d%H%M%S)
	if [ "${action}" -eq 0 ]
	then
		newpathname="${filepath}/${filets}.${filenamext}"
	else
		newpathname="${filepath}/${filets}-${filenamebase}.${filenamext}"
	fi

	mv --verbose "${filepathname}" "${newpathname}"
}

action="${1:-}"
if [ -z "${action}" ]
then
	cat >&2 <<- EOF
		No file argument given

		$(basename $0) [optional action: 0 or 1] filenames..

		.   option 0 : just rename the file to timestamp.ext
		.              this is also the default when action is omitted
		.   option 1 : prepend a timestamp to tyhe current filename ts-timestamp.ext

		EOF
    exit 1
fi

if [ "${action}" = 0 ] || [ "${action}" = 1 ]
then
	action="$1"
	files=("${@:2}")
else
	files=($@)
	action=0 # default just rename to timestamp
fi

for file in "${files[@]}"
do
	rename "${action}" "${file}"
done

